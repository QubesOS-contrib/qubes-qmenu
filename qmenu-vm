#!/bin/sh

dmenu() {

command dmenu -f -nb $theme_0 -nf $theme_1 -sb $qube_label -sf $theme_2 "$@"
}

fmenu_dom0() (

chosefrom=0

while [ -n "$chosefrom" ]; do

  chosefrom=$(printf "New qube\nGlobal preferences\nLogs" |\
    dmenu -l 3 -i -p "dom0:" | awk '{print $1}')

  case $chosefrom in

    New)

      fqvm_create;;

    Global)

      fqubes_prefs;;

    Logs)

      fq_logs;;

    *)
  esac
done
)

fmenu_domu() (

theme_2=$theme_1

qube_label=$(qvm-ls --raw-data "$qube" -O LABEL)

# Change label colors according to user input.
if echo "$@" | grep -q "\--$qube_label"; then

  qube_label=$(echo "$@" | tr ' ' '\n' |\
    grep "\--$qube_label.*" | cut -d= -f2)
fi

chosefrom=0

while [ -n "$chosefrom" ]; do

  chosefrom=$(printf "Applications\nAudio input devices\nBlock devices\nBoot\nBootfrom\nClone\nCommand\nDisk\nFirewall\nKeyboard\nKill\nLogs\nPause\nPCI devices\nPreferences\nReboot\nRemove\nServices\nShutdown\nTags\nUnpause\nUSB devices" |\
    dmenu -l 22 -i -p "$qube:" | awk '{print $1}')

  case $chosefrom in

    Applications)

      fqvm_appmenus;;

    Audio)

      fqvm_device;;

    Block)

      fqvm_device;;

    Boot)

      qvm-start --skip-if-running "$qube"&;;

    Bootfrom)

      qubes-vm-boot-from-device "$qube";;

    Clone)

      fqvm_clone;;

    Command)

      fqvm_run;;

    Disk)

      fqvm_volume;;

    Firewall)

      fqvm_firewall;;

    Keyboard)

      fq_keyboard;;

    Kill)

      answer=$(printf "No\nYes" | dmenu -i -p "Kill $qube?")

      if [ "$answer" = "Yes" ]; then qvm-kill "$qube"& fi;;

    Logs)

      fq_logs;;

    Pause)

      answer=$(printf "No\nYes" | dmenu -i -p "Pause $qube?")

      if [ "$answer" = "Yes" ]; then qvm-pause "$qube"& fi;;

    PCI)

      fqvm_pci;;

    Preferences)

      fqvm_prefs;;

    Reboot)

      answer=$(printf "No\nYes" | dmenu -i -p "Reboot $qube?")

      if [ "$answer" = "Yes" ]; then

        if qvm-check -q --running "$qube"; then

          $(qvm-shutdown --wait "$qube" && qvm-start "$qube")&
        fi
      fi;;

    Remove)

      fqvm_remove;;

    Services)

      fqvm_service;;

    Shutdown)

      answer=$(printf "No\nYes" | dmenu -i -p "Shutdown $qube?")

      if [ "$answer" = "Yes" ]; then qvm-shutdown "$qube"& fi;;

    Tags)

      fqvm_tags;;

    Unpause)

      qvm-unpause "$qube"&;;

    USB)

      fqvm_device;;

    *)
  esac
done
)

fq_keyboard() (

# 'qmenu-vm' does not get informed about the available layouts by the vm itself
# so it is possible that the selected layout is missing inside the vm.
# Getting the info from the vm itself, however, would have security
# implication so we will not switch to use that method.
LAYOUT=$(ls /usr/share/X11/xkb/symbols | dmenu -l 50 -p "$qube:")

if [ -n "$LAYOUT" ]; then

  if test -d /usr/share/X11/xkb/symbols/$LAYOUT; then

    LAYOUT="$LAYOUT/"$(ls /usr/share/X11/xkb/symbols/"$LAYOUT" |\
      dmenu -l 50 -p "$qube:")
  fi

  if ! qvm-run "$qube" "setxkbmap $LAYOUT"; then

    echo "Go back..." | dmenu\
      -p "Error: Could not set keyboard layout to '$LAYOUT' in $qube! Please check the available layouts inside the qube itself."\
      > /dev/null 2>&1
  fi
fi
)

fq_logs() (

if [ "$qube" = "dom0" ]; then

  logs="/var/log/xen/console/hypervisor.log"
else

  logs="/var/log/xen/console/guest-$qube.log\n/var/log/qubes/guid.$qube.log\n/var/log/qubes/qrexec.$qube.log"
fi

entry=0

while [ -n "$entry" ]; do

  entry=$(printf "$logs" | dmenu -i -l 3 -p "$qube:")

  if [ -n "$entry" ]; then

    log=$(dmenu -l 20 -p "$qube:" < "$entry")

    if [ -n "$log" ]; then

      echo "$log" > /var/run/qubes/qubes-clipboard.bin

      printf "dom0" > /var/run/qubes/qubes-clipboard.bin.source
    fi
  fi
done
)

fqubes_prefs() (

property=0

while [ -n "$property" ]; do

  property=$(qubes-prefs |\
    dmenu -l 16 -p "Global preferences:" | awk '{print $1}')

  case $property in

    check_updates_vm)

      value_selected=$(printf "False\nTrue" |\
        dmenu -i -p "Should the system periodically check for domU updates?");;

    clockvm)

      # List netvms via 'qvm-ls'.
      value_selected=$(printf "$(qvm-ls --raw-data --fields NAME,FLAGS |\
        grep '|...N....$' | cut -d '|' -f1)" |\
        dmenu -l 50 -p "Select ClockVM:");;

    default_dispvm)

      if [ -n "$LIST_OF_DISPTEMP" ]; then unset LIST_OF_DISPTEMP; fi

      # [mediocre] Look up disposable templates.
      for n in $(qvm-ls --raw-data -O NAME,FLAGS |\
        grep '|a.......$' | cut -d '|' -f1); do

        if qvm-prefs --get "$n" template_for_dispvms | grep -q True; then

          LIST_OF_DISPTEMP="$LIST_OF_DISPTEMP\n$n"
        fi
      done

      value_selected=$(printf "(None)$LIST_OF_DISPTEMP" |\
        dmenu -l 50 -p "Select default dispvm:")

      if [ "$value_selected" = "(None)" ]; then

        value_selected="none"
      fi;;

    default_kernel)

      value_selected=$(true |\
        dmenu -p "Enter default kernel:")

      if [ -n "$value_selected" ]; then

        answer_selected=$(printf "No\nYes" |\
          dmenu -i -p "Set default kernel to $value_selected?")

        if [ "$answer_selected" != "Yes" ]; then

          unset value_selected
        fi
      fi;;

    default_netvm)

      # List netvms via 'qvm-ls'.
      value_selected=$(printf "$(qvm-ls --raw-data --fields NAME,FLAGS |\
        grep '|...N....$' | cut -d '|' -f1)" |\
        dmenu -l 50 -p "Select default netvm:");;

    default_pool)

      value_selected=$(qvm-pool --list | sed '1d' |\
        dmenu -i -l 30 -p "Select default storage pool:" | awk '{print $1}');;

    default_pool_kernel)

      value_selected=$(qvm-pool --list | sed '1d' |\
        dmenu -i -l 30 -p "Select default storage pool for kernel volumes:"\
        | awk '{print $1}');;

    default_pool_private)

      value_selected=$(qvm-pool --list | sed '1d' |\
        dmenu -i -l 30 -p "Select default storage pool for private volumes:"\
        | awk '{print $1}');;

    default_pool_root)

      value_selected=$(qvm-pool --list | sed '1d' |\
        dmenu -i -l 30 -p "Select default storage pool for root volumes:"\
        | awk '{print $1}');;

    default_pool_volatile)

      value_selected=$(qvm-pool --list | sed '1d' |\
        dmenu -i -l 30 -p "Select default storage pool for volatile volumes:"\
        | awk '{print $1}');;

    default_qrexec_timeout)

      value_selected=$(qubes-prefs --get default_qrexec_timeout | dmenu\
        -p "Enter the time in seconds, after which qrexec connection attempts are deemed a failure:");;

    default_shutdown_timeout)

      value_selected=$(qubes-prefs --get default_shutdown_timeout | dmenu\
        -p "Enter the default time in seconds for vm shutdowns to complete:");;

    default_template)

      # List templatevms via 'qvm-ls'.
      value_selected=$(qvm-ls --raw-data --fields NAME,FLAGS |\
        grep '|t.......$' | cut -d '|' -f1 |\
        dmenu -l 50 -p "Select default template:");;

    management_dispvm)

      if [ -n "$LIST_OF_DISPTEMP" ]; then unset LIST_OF_DISPTEMP; fi

        # [mediocre] Look up disposable templates.
        for n in $(qvm-ls --raw-data -O NAME,FLAGS |\
          grep '|a.......$' | cut -d '|' -f1); do

          if qvm-prefs --get "$n" template_for_dispvms | grep -q True; then

            if [ -z "$LIST_OF_DISPTEMP" ]

              then LIST_OF_DISPTEMP=$n

              else LIST_OF_DISPTEMP="$LIST_OF_DISPTEMP\n$n"
            fi
          fi
        done

        value_selected=$(printf "$LIST_OF_DISPTEMP" |\
          dmenu -l 50 -p "Select management dispvm:");;

    stats_interval)

      value_selected=$(true |\
        dmenu -p "Enter interval in seconds for VM stats reporting:");;

    updatevm)

      # List netvms via 'qvm-ls'.
      value_selected=$(printf "$(qvm-ls --raw-data --fields NAME,FLAGS |\
        grep '|...N....$' | cut -d '|' -f1)" |\
        dmenu -l 50 -p "Select UpdateVM:")

      if [ -n "$value_selected" ]; then

        if ! qvm-check -q --running "$value_selected"; then

          unset value_selected

          echo "Go back..." |\
            dmenu -p "$value_selected needs to be running!" > /dev/null 2>&1
        fi
      fi;;

    *)
  esac

  if [ -n "$value_selected" ]; then

    if ! qubes-prefs --set "$property" "$value_selected"; then

      echo "Go back..." |\
        dmenu -p "Error: Could not set $property to '$value_selected'!"\
        > /dev/null 2>&1
    fi

    unset value_selected
  fi
done
)

fqvm_appmenus() (

option=0

while [ -n "$option" ]; do

  option=$(printf "Available\nSelected" | dmenu -i -l 2 -p "$qube:")

  if [ "$option" = "Available" ]; then

    applications=0

    while [ -n "$applications" ]; do

      # Only show applications that arent already selected for $qube via 'grep -v'.
      applications=$(qvm-appmenus --get-available --i-understand-format-is-unstable "$qube" |\
        grep -v "$(qvm-appmenus --get-whitelist --i-understand-format-is-unstable "$qube")" |\
        dmenu -l 50 -p "$qube:" | awk '{print $1}')

      if [ -n "$applications" ]; then

        # Check validity of input.
        if qvm-appmenus --get-available --i-understand-format-is-unstable "$qube" |\
          awk '{print $1}' | grep -q "^$applications$"; then

          printf "\n$applications" >> "$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list

          applications_modified=1
        fi
      fi
    done

  elif [ "$option" = "Selected" ]; then

    applications=0

    while [ -n "$applications" ]; do

      # Show complete application and .desktop names via 'grep'.
      applications=$(qvm-appmenus --get-available --i-understand-format-is-unstable "$qube" |\
        grep "$(qvm-appmenus --get-whitelist --i-understand-format-is-unstable "$qube")" |\
        dmenu -l 50 -p "$qube:"  | awk '{print $1}')

      if [ -n "$applications" ]; then

        for application in $applications; do

          # Look up linenumber above $application in
          # /whitelisted-appmenus.list and delete whitespace.
          whitespace=$(grep -n1 "^$application$" <\
            "$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list |\
            sed '1q;d' | cut -d- -f1)

          sed -i "${whitespace}{/^$/d;}" "$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list
          sed -i "/$application/d" "$HOME"/.local/share/qubes-appmenus/"$qube"/whitelisted-appmenus.list

          applications_modified=1
        done
      fi
    done
  fi

  # Only update qvm-appmenus down here, *after* the user
  # has quit the application selection.
  if [ -n "$applications_modified" ]; then

    qvm-appmenus -q --update "$qube"

    unset applications_modified
  fi
done
)

fqvm_clone() (

clone_name=$(true | dmenu -p "Enter the name for the clone of $qube:")

if [ -n "$clone_name" ]; then

  option=0

  while [ -n "$option" ]; do

    option=$(printf "Create the clone\nAdvanced options" |\
      dmenu -i -l 2 -p "$qube:"  | awk '{print $1}')

    if [ "$option" = "Advanced" ]; then

      option_adv=0

      while [ -n "$option_adv" ]; do

        option_adv=$(printf "Class\nPool" |\
          dmenu -i -l 2 -p "$clone_name($qube):")

        if [ "$option_adv" = "Class" ]; then

          class=$(printf "AppVM\nDispVM\nStandaloneVM\nTemplateVM" |\
            dmenu -i -l 4 -p "Choose a class for $clone_name:")

          if [ -n "$class" ]; then class="-C $class"; fi

        elif [ "$option_adv" = "Pool" ]; then

          pool=$(qvm-pool --list | sed '1d' | dmenu -i -l 10\
            -p "Select a pool for $clone_name:" | awk '{print $1}')

          if [ -n "$pool" ]; then pool="-P $pool"; fi
        fi
      done

    elif [ "$option" = "Create" ]; then

      unset option

      qvm-clone $class $pool "$qube" "$clone_name"&
    fi
  done
fi
)

fqvm_create() (

new_name=$(true | dmenu -p "Enter the name of the qube to create:")

if [ -n "$new_name" ]; then

  label=$(printf "Purple\nBlue\nGray\nGreen\nYellow\nOrange\nRed\nBlack" |\
    dmenu -i -l 8 -p "Select label for $new_name:"  | awk '{print tolower($0)}')

  if [ -n "$label" ]; then

    QUBEARGS="-l $label"

    class=$(printf "AppVM\nDispVM\nStandaloneVM\nTemplateVM" |\
      dmenu -i -l 4 -p "Choose a class for $new_name:")

    if [ -n "$class" ]; then

      QUBEARGS="$QUBEARGS -C $class"
    fi

    # List templatevms via 'qvm-ls'.
    template=$(printf "(Default)\n(None)\n$(qvm-ls --raw-data --fields NAME,FLAGS |\
      grep '|t.......$' | cut -d '|' -f1)" |\
      dmenu -l 50 -p "Select template for $new_name:")

    if [ "$template" != "(Default)" ] && [ "$template" != "(None)" ]; then

      QUBEARGS="$QUBEARGS -t $template"
    fi

    netvm=$(printf "(Default)\n(None)\n$(qvm-ls --raw-data --fields NAME,FLAGS |\
      grep '|...N....$' | cut -d '|' -f1)" |\
      dmenu -l 50 -p "Select netvm for $new_name:")

    if [ "$netvm" != "(Default)" ]; then

      if [ "$netvm" = "(None)" ]; then unset netvm; fi

      QUBEARGS="$QUBEARGS --prop netvm=$netvm"
    fi

    provides_network=$(printf "No\nYes" |\
      dmenu -i -p "Should $new_name provide networking for other qubes?")

    if [ "$provides_network" = "Yes" ]; then

      QUBEARGS="$QUBEARGS --prop provides_network=true"
    fi

    option=0

    while [ -n "$option" ]; do

      option=$(printf "Create the new qube\nAdvanced options" |\
        dmenu -i -l 2 -p "dom0:" | awk '{print $1}')

      if [ "$option" = "Advanced" ]; then

        option_adv=$(printf "Pool" | dmenu -l 1 -p "$new_name:")

        if [ "$option_adv" = "Pool" ]; then

          pool=$(qvm-pool --list | sed '1d' |\
            dmenu -i -l 10 -p "Select a pool for $new_name:" | awk '{print $1}')

          if [ -n "$pool" ]; then pool="-P $pool"; fi
        fi

      elif [ "$option" = "Create" ]; then

        qvm-create $QUBEARGS $pool "$new_name"&

        unset option
      fi
    done
  fi
fi
)

fqvm_device() (

if ! qvm-check -q --running "$qube"; then

  echo "Go back..." |\
    dmenu -p "$qube needs to be running, in order to attach devices to it."\
    > /dev/null 2>&1
else

  # Depending on the device type, we have to 'awk' different fields later on.
  if [ "$chosefrom" = "Audio" ]; then

    device_type="device mic"

    awk_devicename0=2
    awk_devicename1=10
    awk_targetqube=3

  elif [ "$chosefrom" = "Block" ]; then

    device_type="block"

    awk_devicename0=2
    awk_devicename1=3
    awk_targetqube=4

  elif [ "$chosefrom" = "USB" ]; then

    device_type="usb"

    awk_devicename0=2
    awk_devicename1=10
    awk_targetqube=3
  fi

  devices_list=$(qvm-$device_type)

  device=0

  while [ -n "$device" ]; do

    device=$(echo "$devices_list" | dmenu -l 16 -p "$qube:")

    if [ -n "$device" ] && [ "$(echo "$device" | wc -l)" -eq 1 ]; then

      device_id=$(echo "$device" | awk '{print $1}')

      device_name=$(echo "$device" |\
        awk '{print $'$awk_devicename0'$'$awk_devicename1'}')

      holds_qube=$(echo "$devices_list" | grep "$device_id" |\
        awk '{print $'$awk_targetqube'}')

      if [ -z "$holds_qube" ]; then

        answer=$(printf "No\nYes" |\
          dmenu -i -p "Attach '$device_name' to $qube?")

        if [ "$answer" = "Yes" ]; then

          unset device

          if ! qvm-$device_type attach -q "$qube" "$device_id"; then

           echo "Go back..." | dmenu -p "Error: Could not attach device!"\
             > /dev/null 2>&1
          fi
        fi

      elif [ "$holds_qube" = "$qube" ]; then

        answer=$(printf "No\nYes" |\
          dmenu -i -p "Detach '$device_name' from $qube?")

        if [ "$answer" = "Yes" ]; then

          unset device

          if ! qvm-$device_type detach -q "$holds_qube" "$device_id"; then

            echo "Go back..." | dmenu -p "Error: Could not detach device!"\
              > /dev/null 2>&1
          fi
        fi
      else

        answer=$(printf "No\nYes" | dmenu -i\
          -p "Detach '$device_name' from $holds_qube and attach it to $qube?")

        if [ "$answer" = "Yes" ]; then

          unset device

          if qvm-$device_type detach -q "$holds_qube" "$device_id"; then

            if ! qvm-$device_type attach -q "$qube" "$device_id"; then

              echo "Go back..." | dmenu\
                -p "Error: Could not attach device!" > /dev/null 2>&1
            fi
          fi
        fi
      fi
    fi
  done
fi
)

fqvm_firewall() (

rulenumber_selected=0

while [ -n "$rulenumber_selected" ]; do

  rulenumber_selected=$(qvm-firewall $qube list |\
    dmenu -l 50 -p "$qube:"  | awk '{print $1}')

  if [ "$(echo "$rulenumber_selected" | wc -w)" -eq 1 ]; then

    # This will equal "NO" if the user selects the top row,
    # instead of any existing rule.
    if [ "$rulenumber_selected" != "NO" ]; then

      option=$(printf "Add new rule above rule $rulenumber_selected\nRemove rule $rulenumber_selected" |\
        dmenu -i -l 2 -p "$qube:" | awk '{print $1}')
    else

      option="Add"
    fi

    if [ "$option" = "Remove" ]; then

      answer=$(printf "No\nYes" |\
        dmenu -i -p "Remove rule $rulenumber_selected?")

      if [ "$answer" = "Yes" ]; then

        qvm-firewall "$qube" del --rule-no "$rulenumber_selected"
      fi

    elif [ "$option" = "Add" ]; then

      if [ -n "$RULEARGS" ]; then unset RULEARGS; fi

      action=$(printf "Accept\nDrop" |\
        dmenu -i -l 2 -p "Select action for the new firewall rule:" |\
        awk '{print tolower($0)}')

      if [ -n "$action" ]; then

        RULEARGS="$action"

        specialtarget=$(true | dmenu -p "ACTION=$RULEARGS <specialtarget>")

        if [ -n "$specialtarget" ]; then

          RULEARGS="$RULEARGS SPECIALTARGET=$specialtarget"
        fi

        dsthost=$(true | dmenu -p "ACTION=$RULEARGS <dsthost>")

        if [ -n "$dsthost" ]; then

          RULEARGS="$RULEARGS DSTHOST=$dsthost"
        fi

        proto=$(true | dmenu -p "ACTION=$RULEARGS <proto>")

        if [ -n "$proto" ]; then

          RULEARGS="$RULEARGS PROTO=$proto"
        fi

        if [ "$proto" = "tcp" ] || [ "$proto" = "udp" ]; then

          dstports=$(true | dmenu -p "ACTION=$RULEARGS <dstports>")

          if [ -n "$dstports" ]; then

            RULEARGS="$RULEARGS DSTPORTS=$dstports"
          fi

        elif [ "$proto" = "icmp" ]; then

          icmptype=$(true | dmenu -p "ACTION=$RULEARGS <icmptype>")

          if [ -n "$icmptype" ]; then

            RULEARGS="$RULEARGS ICMPTYPE=$icmptype"
          fi
        fi

        expire=$(true | dmenu -p "ACTION=$RULEARGS <expire>")

        if [ -n "$expire" ]; then

          RULEARGS="EXPIRE=$expire"
        fi

        comment=$(true | dmenu -p "ACTION=$RULEARGS <comment>")

        if [ -n "$comment" ]; then

          RULEARGS="$RULEARGS COMMENT=$comment"
        fi

        answer=$(printf "No\nYes" | dmenu -i\
          -p "Add the following rule to $qube? {{ ACTION=$RULEARGS }}")

        if [ "$answer" = "Yes" ]; then

          if [ -n "$beforerule" ]; then unset beforerule; fi

          if [ "$rulenumber_selected" != "NO" ]; then

            beforerule=$(echo --before "$rulenumber_selected")
          fi

          RULEARGS=$(echo "$RULEARGS" | awk '{print tolower($0)}')

          if ! qvm-firewall "$qube" add $beforerule $RULEARGS; then

            echo "Go back..." | dmenu\
              -p "Error: Failed to add firewall rule! See 'qvm-firewall --help' for more information."\
              > /dev/null 2>&1
          fi
        fi
      fi
    fi
  fi
done
)

fqvm_pci() (

if qvm-check -q --running "$qube"; then

  echo "Go back..." | dmenu\
    -p "$qube needs to be powered off, in order to attach or detach PCI devices."\
    > /dev/null 2>&1
else

  list_pci=$(qvm-pci)

  if ! qvm-prefs --get "$qube" maxmem | grep -q ^0; then

    answer_memorybalancing=$(printf "Continue anyways\nDisable dynamic memory balancing" |\
      dmenu -l 2 -i -p "Dynamic memory balancing is enabled in $qube, some devices might not work!"\
      | awk '{print $1}')

    if [ "$answer_memorybalancing" = "Disable" ]; then

      qvm-prefs --set "$qube" maxmem 0
    fi
  fi

  if qvm-prefs --get "$qube" virt_mode | grep -q ^pvh; then

    answer_virtmode=$(printf "Continue anyways\nSelect another virtualisation mode" |\
      dmenu -l 2 -i -p "$qube is using PVH for its virtualisation mode, which does not support PCI passthrough!"\
      | awk '{print $1}')

    if [ "$answer_virtmode" = "Select" ]; then

      virtmode_selected=$(printf "HVM\nPV" |\
        dmenu -l 2 -i -p "Select virtualisation mode for $qube:")

      if [ -n "$virtmode_selected" ]; then

        qvm-prefs --set "$qube" virt_mode "$virtmode_selected"
      fi
    fi
  fi

  device=0

  while [ -n "$device" ]; do

    device=$(echo "$list_pci" | dmenu -l 30 -p "$qube:")

    if [ -n "$device" ] && [ "$(echo "$device" | wc -l)" -eq 1 ]; then

      device_src=$(echo "$device" | awk '{print $1}' | sed 's/:.*//')
      device_bdf=$(echo "$device" | awk '{print $1}' | sed 's/.*://')

      if echo "$device" | grep -q " $qube "; then

        answer=$(printf "No\nYes" |\
          dmenu -i -p "Detach \"$device_bdf\" from $qube?")

        if [ "$answer" = "Yes" ]; then

          if ! qvm-pci detach "$qube" "$device_src":"$device_bdf"; then

            echo "Go back..." | dmenu\
              -p "Error: Failed to detach \"$device_bdf\" from $qube!"\
              > /dev/null 2>&1
          fi

          list_pci=$(qvm-pci)
        fi
      else

        answer=$(printf "No\nYes" |\
          dmenu -i -p "Attach \"$device_bdf\" to $qube?")

        if [ "$answer" = "Yes" ]; then

          # Check if there is more than one function
          # that belongs to the same device.
          bdf_count=$(echo "$list_pci" | awk '{print $1}' |\
            grep -c $(echo "$device_bdf" | sed 's/\..*//'))

          if [ "$bdf_count" -gt 1 ]; then

            if [ -n "$pci_option" ]; then unset pci_option; fi

              answer_nsrt=$(printf "No\nYes" | dmenu -i\
                -p "\"$device_bdf\" is most likely to be attached with the option 'no-strict-reset' enabled. Please be aware of the security implications! Do you want to attach \"$device_bdf\" with the option 'no-strict-reset' set to true?")

            if [ "$answer_nsrt" = "Yes" ]; then

              pci_option="-o no-strict-reset=True"
            fi
          fi

          if ! qvm-pci attach --persistent $pci_option "$qube" "$device_src:$device_bdf"; then

            echo "Go back..." | dmenu\
              -p "Error: Failed to attach \"$device_bdf\" to $qube!"\
              > /dev/null 2>&1
          fi

          list_pci=$(qvm-pci)
        fi
      fi
    fi
  done
fi
)

fqvm_prefs() (

property=0

while [ -n "$property" ]; do

  property=$(qvm-prefs "$qube" |\
    dmenu -l 45 -p "$qube:" | awk '{print $1}')

  if [ -n "$property" ]; then

    case $property in

      autostart)

        value_selected=$(printf "False\nTrue" |\
          dmenu -i -p "Set autostart of $qube to:");;

      debug)

        value_selected=$(printf "False\nTrue" |\
          dmenu -i -p "Set debug mode of $qube to:");;

      default_dispvm)

        if [ -n "$LIST_OF_DISPTEMP" ]; then unset LIST_OF_DISPTEMP; fi

        # [mediocre] Look up disposable templates.
        for n in $(qvm-ls --raw-data -O NAME,FLAGS |\
          grep '|a.......$' | cut -d '|' -f1); do

          if qvm-prefs --get "$n" template_for_dispvms | grep -q True; then

            LIST_OF_DISPTEMP="$LIST_OF_DISPTEMP\n$n"
          fi
        done

        value_selected=$(printf "(Default)\n(None)$LIST_OF_DISPTEMP" |\
          dmenu -l 50 -p "Select default dispvm for $qube:")

        if [ "$value_selected" = "(None)" ]; then

          value_selected="None"

        elif [ "$value_selected" = "(Default)" ]; then

          value_selected="--default"
        fi;;

      default_user)

        value_selected=$(echo "--default" |\
          dmenu -p "Enter the name of the default user for $qube:");;

      include_in_backups)

        value_selected=$(printf "False\nTrue" |\
          dmenu -i -p "Include $qube in backups?");;

      kernel)

        value_selected=$(echo "--default" |\
          dmenu -p "Enter the kernel to be used by $qube:")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" |\
            dmenu -i -p "Set kernel of $qube to $value_selected?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      kernelopts)

        value_selected=$(echo "--default" |\
          dmenu -p "Enter the kernel options for $qube:")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" | dmenu -i\
            -p "Set kernel options for $qube to \"$value_selected\"?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      label)

        if qvm-check -q --running "$qube"; then

          echo "Go back..." | dmenu\
            -p "$qube needs to be powered off, in order to change its label."\
            > /dev/null 2>&1
        else

          value_selected=$(printf "Purple\nBlue\nGray\nGreen\nYellow\nOrange\nRed\nBlack" |\
            dmenu -i -l 8 -p "Select label for $qube:" |\
            awk '{print tolower($0)}')
        fi;;

      mac)

        value_selected=$(echo "--default" |\
          dmenu -p "Enter the MAC address for $qube:")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" |\
            dmenu -i -p "Set MAC address of $qube to $value_selected?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      maxmem)

        value_selected=$(echo "--default" |\
          dmenu -p "Enter the maximum amount of memory in MB to be allocated to $qube. Setting it to 0 will disable dynamic memory balancing.")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" | dmenu -i\
            -p "Set maximum memory of $qube to $value_selected MB?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      memory)

        value_selected=$(echo "--default" | dmenu\
          -p "Enter the amount of initial memory in MB to be allocated to $qube:")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" | dmenu -i\
            -p "Set initial memory of $qube to $value_selected MB?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      netvm)

        # List netvms via 'qvm-ls'.
        value_selected=$(printf "(Default)\n(None)\n$(qvm-ls --raw-data --fields NAME,FLAGS |\
          grep '|...N....$' | cut -d '|' -f1)" |\
          dmenu -l 50 -p "Select netvm for $qube:")

        if [ "$value_selected" = "(None)" ]; then

          value_selected="None"

        elif [ "$value_selected" = "(Default)" ]; then

          value_selected="--default"
        fi;;

      provides_network)

        value_selected=$(printf "False\nTrue" | dmenu -i\
          -p "Should $qube provide networking to other qubes?");;

      qrexec_timeout)

        value_selected=$(echo "--default" | dmenu\
          -p "Enter the time in seconds, after which qrexec attempt is deemed a failure for $qube:")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" | dmenu -i\
            -p "Set qrexec timeout for $qube to $value_selected seconds?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      shutdown_timeout)

        value_selected=$(echo "--default" | dmenu\
          -p "Enter the time in seconds for shutdown, after which $qube may be forcefully powered off:")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" | dmenu -i\
            -p "Set shutdown timeout for $qube to $value_selected seconds?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      template)

        if qvm-check -q --running "$qube"; then

          echo "Go back..." | dmenu\
            -p "$qube needs to be powered off, in order to change its template."\
            > /dev/null 2>&1
        else

          # List templatevms via 'qvm-ls'.
          value_selected=$(printf "(Default)\n$(qvm-ls --raw-data --fields NAME,FLAGS |\
            grep '|t.......$' | cut -d '|' -f1)" |\
            dmenu -l 50 -p "Select template for $qube:")

          if [ "$value_selected" = "(Default)" ]; then

            value_selected="--default"
          fi
        fi;;

      template_for_dispvms)

        value_selected=$(printf "False\nTrue" | dmenu -i\
          -p "Should $qube be used as a template for disposable qubes?");;

      vcpus)

        value_selected=$(echo "--default" | dmenu\
          -p "Enter the number of CPU cores that should be made available to $qube:")

        if [ -n "$value_selected" ]; then

          answer_selected=$(printf "No\nYes" | dmenu -i\
            -p "Set number of CPU cores available to $qube to $value_selected?")

          if [ "$answer_selected" != "Yes" ]; then

            unset value_selected
          fi
        fi;;

      virt_mode)

        value_selected=$(printf "PVH\nHVM\nPV" |\
          dmenu -i -l 3 -p "Select virtualisation mode for $qube:");;

      *)
    esac

    if [ -n "$value_selected" ]; then

      if ! qvm-prefs --set "$qube" "$property" "$value_selected"; then

        echo "Go back..." |\
          dmenu -p "Error: Could not set $property to '$value_selected'!"\
          > /dev/null 2>&1
      fi

      unset value_selected
    fi
  fi
done
)

fqvm_remove() {

if qvm-check -q --running "$qube"; then

  echo "Go back..." |\
    dmenu -p "$qube needs to be powered off, in order to be removed."\
    > /dev/null 2>&1
else

  confirmation=$(true |\
    dmenu -p "Enter the name of the qube '$qube' in order to remove it:")

  if [ "$qube" = "$confirmation" ]; then

    confirmation_semifinal=$(printf "No\nYes" |\
      dmenu -i -p "Are you sure you want to remove $qube permanently?")

    if [ "$confirmation_semifinal" = "Yes" ]; then

      confirmation_final=$(printf "No\nYes" | dmenu -i\
        -p "Are you really sure you want to remove $qube permanently?")

      if [ "$confirmation_final" = "Yes" ]; then

        qvm-remove -f "$qube"&

        unset chosefrom
      fi
    fi
  fi
fi
}

fqvm_run() (

commandtr=0

while [ -n "$commandtr" ]; do

  commandtr=$(true | dmenu -p "Run command in $qube:")

  if [ -n "$commandtr" ]; then qvm-run "$qube" "$commandtr"& fi
done
)

fqvm_service() (

services=0

while [ -n "$services" ]; do

  services=$(qvm-service "$qube" --list |\
    dmenu -l 32 -p "$qube:" | awk '{print $1}')

  if [ -n "$services" ]; then

    for service in $services; do

      # If the service has already been added to the list,
      # give option to unset it.
      if qvm-service "$qube" --list | grep -q "^$service "; then

         unset="\nUnset"
      fi

      value=$(printf "Disable\nEnable$unset" |\
        dmenu -l 3 -i -p "Select value for '$service':")

      if [ "$value" = "Disable" ]; then

        if ! qvm-service "$qube" "$service" off; then

          echo "Go back..." | dmenu -p "Error: Could not deactivate $service!"\
            > /dev/null 2>&1
        fi

      elif [ "$value" = "Enable" ]; then

        if ! qvm-service "$qube" "$service" on; then

          echo "Go back..." | dmenu -p "Error: Could not activate $service!"\
            > /dev/null 2>&1
        fi

      elif [ "$value" = "Unset" ]; then

        if ! qvm-service "$qube" "$service" --unset; then

          echo "Go back..." | dmenu -p "Error: Could not unset $service!"\
            > /dev/null 2>&1
        fi
      fi

      if [ -n "$unset" ]; then unset unset; fi
    done
  fi
done
)

fqvm_tags() (

tags=0

while [ -n "$tags" ]; do

  tags=$(qvm-tags "$qube" list |\
    dmenu -l 15 -p "$qube:" | awk '{print $1}')

  if [ -n "$tags" ]; then

    for tag in $tags; do

      if qvm-tags "$qube" list | grep -q "^$tag$"; then

        answer=$(printf "No\nYes" |\
          dmenu -i -p "Remove tag '$tag' from $qube?")

        if [ "$answer" = "Yes" ]; then

          qvm-tags "$qube" del "$tag"
        fi
      else

        qvm-tags "$qube" add "$tag"
      fi
    done
  fi
done
)

fqvm_volume() (

qube_class=$(qvm-ls --raw-data -O flags "$qube" | cut -c 1)

# If $qube is template or standalone, give option to extend root storage.
if [ "$qube_class" = "t" ] ||\
   [ "$qube_class" = "s" ] ||\
   [ "$qube_class" = "S" ]; then

  volume=$(printf "Root\nPrivate" |\
    dmenu -l 2 -i -p "$qube:" | awk '{print tolower($0)}')
else

  volume="private"
fi

if [ -n "$volume" ]; then

  current_storage=$(( $(qvm-volume info "$qube:$volume" size) / 1048576 ))

  mebibyte=$(echo "$current_storage" | dmenu\
    -p "Enter the maximum size of $volume storage in MiB to be allocated to $qube:")

  if [ -n "$mebibyte" ]; then

    if [ "$mebibyte" -gt "$current_storage" ]; then

      byte=$(( mebibyte * 1048576 ))

      answer=$(printf "No\nYes" | dmenu -i\
        -p "Increase the maximum $volume storage size of $qube from $current_storage MiB to $mebibyte MiB?")

      if [ "$answer" = "Yes" ]; then

        qvm-volume extend "$qube:$volume" "$byte"&
      fi
    else

      echo "Go back..." | dmenu -p "Error: Can not decrease the maximum $volume storage!"\
        > /dev/null 2>&1
    fi
  fi
fi
)





if [ "$2" = "--light-theme" ]; then

  theme_0='#ffffff'
  theme_1='#000000'
  theme_2='#ffffff'
  qube_label='#000000'
else

  theme_0='#000000'
  theme_1='#ffffff'
  theme_2='#000000'
  qube_label='#ffffff'
fi

case $1 in

  --focused)

    qube=$(xprop -id "$(xdotool getwindowfocus)" |\
      grep "^_QUBES_VMNAME" | cut -d\" -f2)

    if [ -z "$qube" ]; then

      qube=dom0

      fmenu_dom0
    else

      fmenu_domu "$@"
    fi

    exit 1;;

  --qube=*)

    qube=$(echo "$1" | cut -d= -f2)

    if [ "$qube" = "dom0" ]; then

      fmenu_dom0
    else

      fmenu_domu "$@"
    fi

    exit 1;;

  --all|--halted|--paused|--running|--tags=*);;

  *)

    printf "$0 [OPTION] (--light-theme) (--{LABEL}=#{HEX TRIPLET})...\nList, manage and configure your qubes.\n\n --all\n --focused\n --halted\n --paused\n --running\n --qube=[QUBE]\n --tags=[TAG]\n\n\nqmenu v2.3.6\n<https://github.com/sine3o14nnae/qmenu/issues/new>\n\n"

    if [ "$1" = "--help" ]; then exit 0; else exit 2; fi
esac

while true; do

  # Load 'qvm-ls' into a variable so that it doesnt
  # need to reload again after every user operation.
  # Sort qubes after qube label via sed and sort.
  qube_list=$(qvm-ls --no-spinner $1 -O NAME,STATE,LABEL,CLASS\
,TEMPLATE,NETVM,IP,PRIV-MAX,PRIV-CURR,PRIV-USED,ROOT-MAX\
,ROOT-CURR,ROOT-USED,KERNEL,KERNELOPTS |\
  sed 's/ LABEL/ 0\@ /g; s/ purple/ 1\@ /g; s/ blue/ 2\@ /g; s/ gray/ 3\@ /g; s/ green/ 4\@ /g; s/ yellow/ 5\@ /g; s/ orange/ 6\@ /g; s/ red/ 7\@ /g; s/ black/ 8\@ /g' |\
  sort -k3 |\
  sed 's/ 0\@ / LABEL/g; s/ 1\@ / purple/g; s/ 2\@ / blue/g; s/ 3\@ / gray/g; s/ 4\@ / green/g; s/ 5\@ / yellow/g; s/ 6\@ / orange/g; s/ 7\@ / red/g; s/ 8\@ / black/g')

  # Get out of the while loop and refresh 'qvm-ls' by loading it again
  # into $qube_list, whenever the user selects the 'qvm-ls' top row.
  while [ "$qubes" != "NAME" ]; do

    qubes=$(echo "$qube_list" | dmenu -l 69 | awk '{print $1}')

    if [ -z "$qubes" ]; then exit 1; fi

    for qube in $qubes; do

      if [ "$qube" = "dom0" ]; then

        fmenu_dom0

      elif [ "$qube" != "NAME" ]; then

        fmenu_domu "$@"
      fi
    done
  done

  unset qubes
done
